<html>
<head>
<script type="text/javascript">
WB_wombat_Init("https:///web", "20101219102904", "pyrorobotics.org");
</script>
 <link rel="stylesheet" href="../stylesheet.css">
<title>Pyro, Python Robotics: PyroModuleAI:Search</title> <meta http-equiv="Content-Type" content="text/html;">
</head>
<body bgcolor="#ffffff">
<table border="0" cellpadding="0" cellspacing="0">
  <tr>
   <td width="804" colspan="8" align="center"><img src="../images/PyroLogo.gif" width="800" height="100"></td>
  </tr>
  <tr>
<td>[&nbsp;<a href="../page_Pyro/">Home</a>&nbsp;]</td><td>[&nbsp;<a href="../page_PyroSoftware/">Software</a>&nbsp;]</td><td>[&nbsp;<a href="../page_PyroCurriculum/">Curriculum</a>&nbsp;]</td><td>[&nbsp;<a href="../page_PyroHardware/">Hardware</a>&nbsp;]</td><td>[&nbsp;<a href="../page_PyroCommunity/">Community</a>&nbsp;]</td><td>[&nbsp;<a href="../page_PyroWhatsNew/">News</a>&nbsp;]</td><td>[&nbsp;<a href="../page_PyroPublications/">Publications</a>&nbsp;]</td><td>[&nbsp;<a href="../page_FindPage/">Search</a>&nbsp;]</td>  </tr>
</table>
<table width="804" border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="8">
<p><hr>
<p>
<p>
<h1 width="804"> Pyro Module AI: Search</h1>
<p>
This module discusses search, followed by an assignment on the Sliding Blocks Puzzle.
<p>
<p>
<h2 width="804"> Assignment: Sliding Blocks Puzzle</h2>
<p>
This puzzle consists of a 3 x 3 board with eight numbered tiles and a blank space. A tile adjacent to the blank space can slide into the space. The object is to figure out the steps needed to unscramble the tiles to reach the goal configuration.
<p>
For this problem, a state should specify the configuration of the eight tiles and the blank space on the board. The operators are most easily represented as moving the blank up, down, left, or right, rather than creating operators for each of the numbered tiles.
<p>
For example, suppose we wanted to get from the start state to the goal state given below:
<p>
<pre class="code">
  1 2 3     1 2 3
  8   6     8   4
  7 5 4     7 6 5
  Start     Goal
</pre>
<p>
We could accomplish this with the following sequence of operators on the blank:
<p>
<pre class="code">
   1 2 3   RIGHT   1 2 3   DOWN   1 2 3   LEFT   1 2 3    UP    1 2 3
   8   6    ---&gt;   8 6     ---&gt;   8 6 4   ---&gt;   8 6 4   ---&gt;   8   4
   7 5 4           7 5 4          7 5            7   5          7 6 5
</pre>
<p>
<p>
<h3 width="804"> Part 1: Uninformed Search</h3>
<p>
<ol type="1"><li>Write an <tt class="wiki">EightPuzzleState</tt> class in a file called <tt class="wiki">EightPuzzleState.py</tt> that implements states and operators for the 8-puzzle. Your code should work with these files: <a href="../page_SearchProgram/">SearchProgram</a> (cut a paste code into a file named <tt class="wiki">Search.py</tt>) and <a href="../page_DataStructuresProgram/">DataStructuresProgram</a> (cut and paste code into a file named <tt class="wiki">DataStructures.py</tt>). Your <tt class="wiki">EightPuzzleState</tt> constructor should take the following nine parameters as input, in the order shown:</li>
</ol><p>
<pre class="code">
   nw    northwest element
   n     north element
   ne    northeast element
   w     west element
   c     central element
   e     east element
   sw    southwest element
   s     south element
   se    southeast element
</pre>
<p>
Values should be the numbers 1 through 8 for the puzzle pieces or a space character for the blank. For example, the above goal state would be created by calling:
<p>
<pre class="code">
&gt;&gt;&gt; EightPuzzleState(1, 2, 3, 8, ' ', 4, 7, 6, 5)
</pre>
<p>
You may represent 8-puzzle states internally however you like, but a simple list representation is probably easiest. If you choose this approach, you may find it convenient to also keep track of the current position of the blank as a separate state variable. You must implement a {{__eq__}} method to test equality. 
<p>
Import your new file from <tt class="wiki">Search.py</tt> by inserting:
<p>
<pre class="code">
from EightPuzzleState import *
</pre>
<p>
An 8-puzzle state should provide a method called <tt class="wiki">applyOperators()</tt>, which returns a list of (state, action) pairs representing the new states generated by applying all operators to the original state. Each action is a string describing the move that generated the associated state, and should be of the form &quot;slide 3 to the left&quot;, &quot;slide 8 up&quot;, etc.
<p>
Also you should define a <tt class="wiki">__repr__</tt> method to use for program output. Probably the most concise description is simply a picture of the board configuration, as in the above examples.
<p>
Finally, add a method name <tt class="wiki">getTile(x,y)</tt> that will return the item in row y and col x.
<p>
So, in review, your job is to complete this template:
<p>
<pre class="code">
from Search import *
class EightPuzzleState:
    def __init__(self, nw, n, ne, w, c, e, sw, s, se):
        DO-SOME-INITIALIZATION
    def applyOperators(self):
        # returns [(EightPuzzleState, description), ...]
        return LIST-OF-POSSIBLE-MOVES 
    def __eq__(self, other):
        # returns boolean value
        return EQUAL? 
    def __repr__(self):
        return STRING-REPRESENTATION-OF-STATE
    def getTile(self, x, y):
        &quot;&quot;&quot;
        This is used in the tile displaying program below.
        &quot;&quot;&quot;
        return ITEM-IN-POSITION-X-Y
goal = EightPuzzleState(1,2,3,8,' ',4,7,6,5)
A    = EightPuzzleState(1,3,' ',8,2,4,7,6,5)
B    = EightPuzzleState(1,3,4,8,6,2,' ',7,5)
C    = EightPuzzleState(1,3,' ',4,2,5,8,7,6)
D    = EightPuzzleState(7,1,2,8,' ',3,6,5,4)
E    = EightPuzzleState(8,1,2,7,' ',4,6,5,3)
SolveIt(A, goal)
</pre>
<p>
That's it! You can now test your program on the following starting states A-E (each is progressively harder) using the same goal each time. To save you some typing, code for creating these states is available here: <a href="../page_Examples/">Examples</a>.
<p>
<pre class="code">
      1 3      1 3 4    1 3      7 1 2    8 1 2      1 2 3
      8 2 4    8 6 2    4 2 5    8   3    7   4      8   4
      7 6 5      7 5    8 7 6    6 5 4    6 5 3      7 6 5
        A        B        C        D        E        goal
</pre>
<p>
<ol type="2" start="2"><li>Modify the <tt class="wiki">UninformedSearch</tt> function in <tt class="wiki">Search.py</tt> so that it keeps track of the total number of nodes expanded and the total number of nodes generated during a search. Also, your program should impose a maximum limit of 3500 node expansions on any search, in order to prevent searches from taking too long.</li>
</ol><p>
<ol><p>You may also use <a href="../page_PuzzleDisplayerProgram/">PuzzleDisplayerProgram</a> to watch your program move the tiles around. Make sure that the file <tt class="wiki">Search.py</tt> imports or defines your search function, and that there is an alias to the search function called <tt class="wiki">SolveIt</tt>. For example, if your search function is called <tt class="wiki">BreadthFirst</tt>, then you should have:
</ol><p>
<pre class="code">
SolveIt = BreadthFirst
</pre>
<p>
<ol><p>Change the variable <tt class="wiki">SolveIt</tt> to a different function to compare:
</ol><p>
<pre class="code">
SolveIt = DepthFirst
SolveIt = UniformCost
</pre>
<p>
You will also need to define a method called <tt class="wiki">getTile(x, y)</tt> that returns the item (number or space) in the x,y position (where upper left-hand corner is 0,0 and the bottom right-hand corner is (2,2)).
<p>
Finally, save the following gif images in your subdirectory for an additionally nice display:
<p>
<img src="../_dblank/images/1.gif">
<img src="../_dblank/images/2.gif">
<img src="../_dblank/images/3.gif">
<img src="../_dblank/images/4.gif">
<img src="../_dblank/images/5.gif">
<img src="../_dblank/images/6.gif">
<img src="../_dblank/images/7.gif">
<img src="../_dblank/images/8.gif">
<p>
Save the above <tt class="wiki">PuzzleDisplayerProgram</tt> as <tt class="wiki">PuzzleDisplayer.py</tt>. To run the program, try:
<p>
<pre class="code">
A -&gt; goal: python PuzzleDisplayer.py 13s824765 1238s4765
B -&gt; goal: python PuzzleDisplayer.py 134862s75 1238s4765
C -&gt; goal: python PuzzleDisplayer.py 13s425876 1238s4765
D -&gt; goal: python PuzzleDisplayer.py 7128s3654 1238s4765
E -&gt; goal: python PuzzleDisplayer.py 8127s4653 1238s4765
      1 3      1 3 4    1 3      7 1 2    8 1 2      1 2 3
      8 2 4    8 6 2    4 2 5    8   3    7   4      8   4
      7 6 5      7 5    8 7 6    6 5 4    6 5 3      7 6 5
        A        B        C        D        E        goal
</pre>
<p>
Specifically, enter this at the prompt:
<p>
<pre class="code">
python PuzzleDisplayer.py 13s824765 1238s4765
</pre>
<p>
where <tt class="wiki">13s824765</tt> is the start state, and <tt class="wiki">1238s4765</tt> is the goal state ('s' is the space).
<p>
<ol type="4" start="4"><li>Make a table showing the length of the solution found by <tt class="wiki">BreadthFirst</tt>, <tt class="wiki">DepthFirst</tt>, and <tt class="wiki">UniformCost</tt> on the above starting states, as well as the number of nodes expanded and generated. If the search is unsuccessful record that as well. Does changing the order in which the operators are applied in <tt class="wiki">applyOperators()</tt> have any effect on the outcome of a search?</li>
</ol><p>
<p>
<h3 width="804"> Part 2: A* Search</h3>
<p>
<ol type="1"><li>Using <tt class="wiki">UninformedSearch</tt> as a guide, define a new search function called <tt class="wiki">HeuristicSearch</tt> that takes an extra input parameter heuristic, which will be a heuristic function on puzzle states. This function, given a state and a goal, should compute an estimate of the number of moves required to get from the state to the goal. You will also need to modify nodes to keep track of heuristic values in addition to path costs. Greedy search and A* search can then be implemented as shown below:</li>
</ol><p>
<pre class="code">
def Greedy(initialState, goalState, heuristic):
    fringe = PriorityQueue(lambda node: node.h)
    return HeuristicSearch(initialState, goalState, fringe, heuristic)
def A_star(initialState, goalState, heuristic):
    fringe = PriorityQueue(lambda node: node.g + node.h)
    return HeuristicSearch(initialState, goalState, fringe, heuristic)
</pre>
<p>
<ol type="2" start="2"><li>Implement the two heuristic functions we discussed above: (1) number of tiles out of place, and (2) Manhattan distance. You should call these functions h1 and h2, respectively.</li>
</ol><p>
<ol type="3"><li>Test your program on the starting states A-E from Part 1, as well as states F-H below, using the same goal each time. Again, each test is progressively harder.</li>
</ol><p>
<pre class="code">
  1 2 3    2 6 3    7 3 4    7 4 5
  8   4    4   5    6 1 5    6   3
  7 6 5    1 8 7    8   2    8 1 2
  goal       F        G        H
F    = EightPuzzleState(2,6,3,4,' ',5,1,8,7)
G    = EightPuzzleState(7,3,4,6,1,5,8,' ',2)
H    = EightPuzzleState(7,4,5,6,' ',3,8,1,2)
goal = EightPuzzleState(1,2,3,8,' ',4,7,6,5)
SolveIt(F, goal)
</pre>
<p>
<ol type="4" start="4"><li>Make a table showing how many nodes are expanded and generated by A* search using heuristic h1 (number of tiles out of place) versus heuristic h2 (Manhattan distance) on test cases A-H. If the search is unsuccessful record that as well. Since the h2 estimate is always greater than or equal to the h1 estimate, we would expect A* to expand fewer nodes when using h2. Do your results support this?</li>
</ol><p>
<ol type="5"><li>Try greedy search on the same set of test cases A-H. If the search finds a solution, record its length and the number of nodes expanded and generated. If not, record failure.</li>
</ol><p>
<ol type="6"><li>Try your search on the following 15 puzzles. Report your findings.</li>
</ol><p>
<pre class="code">
I    = FifteenPuzzleState(5,1,11,7,
                          9,2,12,4,
                          13,14,3,10,
                          8,' ',6,15)
J    = FifteenPuzzleState(1,2,7,4,
                          9,5,8,10,
                          13,15,6,12,
                          14,' ',3,11)
K    = FifteenPuzzleState(7,9,4,1,
                          13,6,5,10,
                          ' ',8,3,12,
                          14,15,2,11)
goal = FifteenPuzzleState(1,2,3,4,
                          5,6,7,8,
                          9,10,11,12,
                          13,14,15,' ')
</pre>
<p>
<p>
<h3 width="804"> Part 3: Extra Credit</h3>
<p>
Now use your A* search engine to solve a variant of the sliding-blocks puzzle in which there are nine blocks of different sizes, as well as two independent spaces, as shown below:
<p>
<pre class="code">
  +-----+-----+-----+-----+-----+
  |     |     |  4  |     |     |
  |  2  |  3  +-----+  8  |  9  |
  |     |     |  5  |     |     |
  +-----+-----+-----+-----+-----+
  |           |     |     6     |
  |     1     +-----+-----------+
  |           |     |     7     |
  +-----------+-----+-----------+
</pre>
<p>
That is, there is one tile that is 2 x 2 (Tile #1), two tiles that are 1 x 1 (Tiles #4 and #5), four tiles that are 1 x 2 (Tiles #2, #3, #8, and #9) and two tiles that are 2 x 1 (Tiles #6 and #7). In addition, there are two empty 1 x 1 places (to the right of Tile #1).
<p>
You will need to define a new board representation, new state operators, and a new heuristic evaluation function for the 9-puzzle, but you shouldn't have to modify your search engine. You will also probably need to come up with a different way of printing puzzle states.
<p>
For testing purposes, define three start states and three goal states of your choosing. Call these states startA9, startB9, startC9, goalA9, goalB9, and goalC9. Call your heuristic function h9. To solve the 9-puzzle, simply invoke A* with the appropriate states and heuristic function:
<p>
<pre class="code">
&gt;&gt;&gt; A_star(startA9, goalA9, h9)
</pre>
<p>
<p>
<p>
<h3 width="804"> Turning in your homework</h3>
<p>
Files to submit:
<p>
<ul><li><tt class="wiki">Search.py</tt></li>
<li><tt class="wiki">EightPuzzleState.py</tt></li>
<li><tt class="wiki">NinePuzzleState.py</tt> (extra credit)</li>
</ul><p>
You should not make any changes to <tt class="wiki">DataStructures.py</tt>, and, therefore, do not have to submit it.
<p>
<hr>
<p>
This assignment was based on previous work by Doug Blank, Jim Marshall, Lisa Meeden, David Leake, and Erich Smythe.
<p>
<p>
<h1 width="804"> Pyro Modules Table of Contents</h1>
<p>
<ul><li><a href="../page_Pyro/">Pyro</a> - Back to Pyro main page</li>
<li><a href="http://cs.brynmawr.edu/BeyondLegos/"><img border="0" width="11" src="../wiki/img/moin-png">&nbsp;Beyond Legos</a> - NSF grant that pays for Pyro</li>
</ul><p>
<p>
<h2 width="804"> Modules</h2>
<ol><p>
<li><a href="../page_PyroModuleIntroduction/">PyroModuleIntroduction</a></li>
<li><a href="../page_PyroModuleObjectOverview/">PyroModuleObjectOverview</a></li>
<li><a href="../page_PyroModulePythonIntro/">PyroModulePythonIntro</a></li>
<li><a href="../page_PyroModuleDirectControl/">PyroModuleDirectControl</a></li>
<li><a href="../page_PyroModuleSequencingControl/">PyroModuleSequencingControl</a></li>
<li><a href="../page_PyroModuleBehaviorBasedControl/">PyroModuleBehaviorBasedControl</a></li>
<li><a href="../page_PyroModuleReinforcementLearning/">PyroModuleReinforcementLearning</a></li>
<li><a href="../page_PyroModuleNeuralNetworks/">PyroModuleNeuralNetworks</a></li>
<li><a href="../page_PyroModuleEvolutionaryAlgorithms/">PyroModuleEvolutionaryAlgorithms</a></li>
<li><a href="../page_PyroModuleComputerVision/">PyroModuleComputerVision</a></li>
<li><a href="../page_PyroModuleMapping/">PyroModuleMapping</a></li>
<li><a href="../page_PyroModuleMultirobot/">PyroModuleMultirobot</a></li>
<li><a href="../page_FurtherReading/">FurtherReading</a></li>
</ol><p>
<p>
<h2 width="804"> Additional Resources</h2>
<ol><p>
<li><a href="../page_PyroIndex/">PyroIndex</a></li>
<li><a href="../page_PyroAdvancedTopics/">PyroAdvancedTopics</a></li>
<li><a href="../page_PyroUserManual/">PyroUserManual</a></li>
<li><a href="../video/"><img border="0" width="11" src="../wiki/img/moin-png">&nbsp;Pyro Tutorial Movies</a></li>
</ol><p>
Reference: <a href="../page_PyroSiteNotes/">PyroSiteNotes</a>
<p>
<p>
<p><hr align="left" width="804"></td></tr>
</table><table width="804" border="0" cellpadding="0" cellspacing="0"><tr><td>[&nbsp;<a href="../page_Pyro/">Home</a>&nbsp;]</td><td>[&nbsp;<a href="../page_PyroSoftware/">Software</a>&nbsp;]</td><td>[&nbsp;<a href="../page_PyroCurriculum/">Curriculum</a>&nbsp;]</td><td>[&nbsp;<a href="../page_PyroHardware/">Hardware</a>&nbsp;]</td><td>[&nbsp;<a href="../page_PyroCommunity/">Community</a>&nbsp;]</td><td>[&nbsp;<a href="../page_PyroWhatsNew/">News</a>&nbsp;]</td><td>[&nbsp;<a href="../page_PyroPublications/">Publications</a>&nbsp;]</td><td>[&nbsp;<a href="../page_FindPage/">Search</a>&nbsp;]</td></tr>
<tr><td colspan="8">
<br>
    <a href="http://creativecommons.org/licenses/by-sa/2.0/">
       <img alt="CreativeCommons" border="0" src="../html/somerights.gif">
    </a>
<a href="http://emergent.brynmawr.edu/index.cgi/PyroModuleAI_3aSearch?action=show">View Wiki Source</a> | <a href="http://emergent.brynmawr.edu/index.cgi/PyroModuleAI_3aSearch?action=edit">Edit Wiki Source</a> | <a href="mailto:dblank@cs.brynmawr.edu">Mail Webmaster</a></td></tr>
</table>
</body>
</html>